<?php

namespace Satag\DoctrineFirebirdDriver\Test\Platforms;

use Doctrine\DBAL\Exception;
use Doctrine\DBAL\Platforms\AbstractPlatform;
use Doctrine\DBAL\Schema\Column;
use Doctrine\DBAL\Schema\ColumnDiff;
use Doctrine\DBAL\Schema\Comparator;
use Doctrine\DBAL\Schema\ForeignKeyConstraint;
use Doctrine\DBAL\Schema\Sequence;
use Doctrine\DBAL\Schema\Table;
use Doctrine\DBAL\Schema\TableDiff;
use Doctrine\DBAL\Types\Type;
use Doctrine\DBAL\Types\Types;
use Satag\DoctrineFirebirdDriver\Platforms\Firebird3Platform;

use function sprintf;
use function strtoupper;
use function uniqid;

/** @extends AbstractPlatformTestCase<Firebird3Platform> */
class Firebird3PlatformTest extends AbstractPlatformTestCase
{

    /** @return mixed[][] */
    public static function dataValidIdentifiers(): iterable
    {
        return [
            ['a'],
            ['foo'],
            ['Foo'],
            ['Foo123'],
            ['Foo#bar_baz$'],
            ['"a"'],
            ['"1"'],
            ['"foo_bar"'],
            ['"@$%&!"'],
        ];
    }

    /** @dataProvider dataValidIdentifiers */
    public function testValidIdentifiers(string $identifier): void
    {
        $platform = $this->createPlatform();
        $platform->assertValidIdentifier($identifier);

        $this->expectNotToPerformAssertions();
    }

    /** @return mixed[][] */
    public static function dataInvalidIdentifiers(): iterable
    {
        return [
            ['1'],
            ['abc&'],
            ['abc-def'],
            ['"'],
            ['"foo"bar"'],
        ];
    }

    /** @dataProvider dataInvalidIdentifiers */
    public function testInvalidIdentifiers(string $identifier): void
    {
        $this->expectException(Exception::class);

        $platform = $this->createPlatform();
        $platform->assertValidIdentifier($identifier);
    }

    public function createPlatform(): AbstractPlatform
    {
        return new Firebird3Platform();
    }

    public function getGenerateTableSql(): string
    {
        return 'CREATE TABLE test (id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL, test VARCHAR(255) DEFAULT NULL, CONSTRAINT TEST_PK PRIMARY KEY (id))';
    }

    /**
     * {@inheritDoc}
     */
    public function getGenerateTableWithMultiColumnUniqueIndexSql(): array
    {
        return [
            'CREATE TABLE test (foo VARCHAR(255) DEFAULT NULL, bar VARCHAR(255) DEFAULT NULL)',
            'CREATE UNIQUE INDEX UNIQ_D87F7E0C8C73652176FF8CAA ON test (foo, bar)',
        ];
    }

    public function testRLike(): void
    {
        self::assertEquals('SIMILAR TO', $this->platform->getRegexpExpression());
    }

    public function testGeneratesSqlSnippets(): void
    {
        self::assertEquals('"', $this->platform->getIdentifierQuoteCharacter());
        self::assertEquals(
            'column1 || column2 || column3',
            $this->platform->getConcatExpression('column1', 'column2', 'column3'),
        );
    }


    public function testCreateDatabaseSQL(): void
    {
        self::assertEquals('CREATE DATABASE foobar', $this->platform->getCreateDatabaseSQL('foobar'));
    }

    public function testDropDatabaseSQL(): void
    {
        self::assertEquals('DROP DATABASE foobar', $this->platform->getDropDatabaseSQL('foobar'));
    }

    public function testDropTable(): void
    {
        $expected = 'EXECUTE BLOCK AS
BEGIN
  EXECUTE STATEMENT \'EXECUTE BLOCK AS DECLARE TMP_VIEW_NAME varchar(255);  BEGIN FOR SELECT TRIM(v.RDB$VIEW_NAME) FROM RDB$VIEW_RELATIONS v, RDB$RELATIONS r WHERE TRIM(UPPER(v.RDB$RELATION_NAME)) = TRIM(UPPER(\'\'foobar\'\')) AND v.RDB$RELATION_NAME = r.RDB$RELATION_NAME AND (r.RDB$SYSTEM_FLAG IS DISTINCT FROM 1) AND (r.RDB$RELATION_TYPE = 0) INTO :TMP_VIEW_NAME DO BEGIN EXECUTE STATEMENT \'\'DROP VIEW "\'\'||:TMP_VIEW_NAME||\'\'"\'\'; END END \';
  EXECUTE STATEMENT \'EXECUTE BLOCK AS BEGIN EXECUTE STATEMENT \'\'DROP TABLE foobar\'\'; END \';
END
';
        self::assertEquals($expected, $this->platform->getDropTableSQL('foobar'));
    }

    public function testGeneratesTypeDeclarationForIntegers(): void
    {
        self::assertEquals(
            'INTEGER',
            $this->platform->getIntegerTypeDeclarationSQL([]),
        );
        self::assertEquals(
            'INTEGER GENERATED BY DEFAULT AS IDENTITY',
            $this->platform->getIntegerTypeDeclarationSQL(['autoincrement' => true]),
        );
        self::assertEquals(
            'INTEGER GENERATED BY DEFAULT AS IDENTITY',
            $this->platform->getIntegerTypeDeclarationSQL(
                ['autoincrement' => true, 'primary' => true],
            ),
        );
    }

    public function testGeneratesTypeDeclarationsForStrings(): void
    {
        self::assertEquals(
            'CHAR(10)',
            $this->platform->getStringTypeDeclarationSQL(
                ['length' => 10, 'fixed' => true],
            ),
        );
        self::assertEquals(
            'VARCHAR(50)',
            $this->platform->getStringTypeDeclarationSQL(['length' => 50]),
        );
        self::assertEquals(
            'VARCHAR(255)',
            $this->platform->getStringTypeDeclarationSQL([]),
        );
    }

    public function testPrefersIdentityColumns(): void
    {
        self::assertTrue($this->platform->prefersIdentityColumns());
    }

    public function testSupportsIdentityColumns(): void
    {
        self::assertTrue($this->platform->supportsIdentityColumns());
    }

    public function testSupportsSavePoints(): void
    {
        self::assertTrue($this->platform->supportsSavepoints());
    }

    protected function supportsCommentOnStatement(): bool
    {
        return true;
    }

    public function getGenerateIndexSql(): string
    {
        return 'CREATE INDEX my_idx ON mytable (user_name, last_login)';
    }

    public function getGenerateUniqueIndexSql(): string
    {
        return 'CREATE UNIQUE INDEX index_name ON test (test, test2)';
    }

    protected function getGenerateForeignKeySql(): string
    {
        return 'ALTER TABLE test ADD FOREIGN KEY (fk_name_id) REFERENCES other_table (id)';
    }

    /**
     * @param mixed[] $options
     *
     * @dataProvider getGeneratesAdvancedForeignKeyOptionsSQLData
     */
    public function testGeneratesAdvancedForeignKeyOptionsSQL(array $options, string $expectedSql): void
    {
        $foreignKey = new ForeignKeyConstraint(['foo'], 'foreign_table', ['bar'], null, $options);

        self::assertSame($expectedSql, $this->platform->getAdvancedForeignKeyOptionsSQL($foreignKey));
    }



    public function testModifyLimitQuery(): void
    {
        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', 10, 0);
        self::assertEquals('SELECT * FROM user ROWS 1 TO 10', $sql);
    }

    public function testModifyLimitQueryWithEmptyOffset(): void
    {
        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', 10);
        self::assertEquals('SELECT * FROM user ROWS 1 TO 10', $sql);
    }

    public function testModifyLimitQueryWithNonEmptyOffset(): void
    {
        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', 10, 10);

        self::assertEquals(
            'SELECT * FROM user ROWS 11 TO 20',
            $sql,
        );
    }

    public function testModifyLimitQueryWithEmptyLimit(): void
    {
        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user', null, 10);

        self::assertEquals(
            'SELECT * FROM user ROWS 11 TO 9223372036854775807',
            $sql,
        );
    }

    public function testModifyLimitQueryWithAscOrderBy(): void
    {
        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user ORDER BY username ASC', 10);
        self::assertEquals('SELECT * FROM user ORDER BY username ASC ROWS 1 TO 10', $sql);
    }

    public function testModifyLimitQueryWithDescOrderBy(): void
    {
        $sql = $this->platform->modifyLimitQuery('SELECT * FROM user ORDER BY username DESC', 10);
        self::assertEquals('SELECT * FROM user ORDER BY username DESC ROWS 1 TO 10', $sql);
    }

    public function testGenerateTableWithAutoincrement(): void
    {
        $columnName = strtoupper('id' . uniqid());
        $tableName  = strtoupper('table' . uniqid());
        $table      = new Table($tableName);
        $column     = $table->addColumn($columnName, Types::INTEGER);
        $column->setAutoincrement(true);

        self::assertSame([
            sprintf('CREATE TABLE %s (%s INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL)', $tableName, $columnName),
        ], $this->platform->getCreateTableSQL($table));
    }

    /**
     * {@inheritDoc}
     */
    public function getCreateTableColumnCommentsSQL(): array
    {
        return [
            'CREATE TABLE test (id INTEGER NOT NULL, CONSTRAINT TEST_PK PRIMARY KEY (id))',
            "COMMENT ON COLUMN test.id IS 'This is a comment'",
        ];
    }

    /**
     * {@inheritDoc}
     */
    public function getCreateTableColumnTypeCommentsSQL(): array
    {
        return [
            'CREATE TABLE test (id INTEGER NOT NULL, data BLOB SUB_TYPE TEXT NOT NULL, CONSTRAINT TEST_PK PRIMARY KEY (id))',
            "COMMENT ON COLUMN test.data IS '(DC2Type:array)'",
        ];
    }


    public function testAlterTableNotNULL(): void
    {
        $tableDiff                          = new TableDiff('mytable');
        $tableDiff->changedColumns['foo']   = new ColumnDiff(
            'foo',
            new Column(
                'foo',
                Type::getType(Types::STRING),
                ['default' => 'bla', 'notnull' => true],
            ),
            ['type'],
        );
        $tableDiff->changedColumns['bar']   = new ColumnDiff(
            'bar',
            new Column(
                'baz',
                Type::getType(Types::STRING),
                ['default' => 'bla', 'notnull' => true],
            ),
            ['type', 'notnull'],
        );
        $tableDiff->changedColumns['metar'] = new ColumnDiff(
            'metar',
            new Column(
                'metar',
                Type::getType(Types::STRING),
                ['length' => 2000, 'notnull' => false],
            ),
            ['notnull'],
        );

        $expectedSql = [
            0 => 'ALTER TABLE mytable ALTER COLUMN foo TYPE VARCHAR(255)',
            1 => 'ALTER TABLE mytable ALTER COLUMN bar TYPE VARCHAR(255)',
            2 => 'ALTER TABLE mytable ALTER bar SET NOT NULL',
            3 => 'ALTER TABLE mytable ALTER metar DROP NOT NULL',
        ];

        self::assertEquals($expectedSql, $this->platform->getAlterTableSQL($tableDiff));
    }
    /**
     * {@inheritDoc}
     */
    protected function getAlterStringToFixedStringSQL(): array
    {
        return ['ALTER TABLE mytable ALTER COLUMN name TYPE CHAR(2)'];
    }

    /**
     * {@inheritDoc}
     */
    protected function getQuotedColumnInPrimaryKeySQL(): array
    {
        return ['CREATE TABLE "quoted" ("create" VARCHAR(255) NOT NULL, CONSTRAINT "quoted_PK" PRIMARY KEY ("create"))'];
    }

    /**
     * {@inheritDoc}
     */
    protected function getQuotedColumnInIndexSQL(): array
    {
        return [
            'CREATE TABLE "quoted" ("create" VARCHAR(255) NOT NULL)',
            'CREATE INDEX IDX_22660D028FD6E0FB ON "quoted" ("create")',
        ];
    }

    /**
     * {@inheritDoc}
     */
    protected function getQuotedNameInIndexSQL(): array
    {
        return [
            'CREATE TABLE test (column1 VARCHAR(255) NOT NULL)',
            'CREATE INDEX "key" ON test (column1)',
        ];
    }

    /**
     * {@inheritDoc}
     */
    protected function getQuotedColumnInForeignKeySQL(): array
    {
        return [
            'CREATE TABLE "quoted" ("create" VARCHAR(255) NOT NULL, foo VARCHAR(255) NOT NULL, '
                . '"bar" VARCHAR(255) NOT NULL)',
            'ALTER TABLE "quoted" ADD CONSTRAINT FK_WITH_RESERVED_KEYWORD FOREIGN KEY ("create", foo, "bar")'
                .' REFERENCES "foreign" ("create", bar, "foo-bar")',
            'ALTER TABLE "quoted" ADD CONSTRAINT FK_WITH_NON_RESERVED_KEYWORD FOREIGN KEY ("create", foo, "bar")'
                . ' REFERENCES foo ("create", bar, "foo-bar")',
            'ALTER TABLE "quoted" ADD CONSTRAINT FK_WITH_INTENDED_QUOTATION FOREIGN KEY ("create", foo, "bar")'
                . ' REFERENCES "foo-bar" ("create", bar, "foo-bar")',
            'CREATE INDEX IDX_22660D028FD6E0FB8C736521D79164E3 ON "quoted" ("create", foo, "bar")',
        ];
    }









    public function testReturnsBinaryTypeLongerThanMaxDeclarationSQL(): void
    {
        self::assertSame('BLOB', $this->platform->getBinaryTypeDeclarationSQL(['length' => 8192]));
        self::assertSame('BLOB', $this->platform->getBinaryTypeDeclarationSQL(['fixed' => true, 'length' => 8192]));
    }

    public function testUsesSequenceEmulatedIdentityColumns(): void
    {
        self::assertFalse($this->platform->usesSequenceEmulatedIdentityColumns());
    }

    public function testReturnsIdentitySequenceName(): void
    {
        self::assertSame('MYTABLE.MYCOLUMN', $this->platform->getIdentitySequenceName('mytable', 'mycolumn'));
        self::assertSame('"mytable".MYCOLUMN', $this->platform->getIdentitySequenceName('"mytable"', 'mycolumn'));
        self::assertSame('MYTABLE."mycolumn"', $this->platform->getIdentitySequenceName('mytable', '"mycolumn"'));
        self::assertSame('"mytable"."mycolumn"', $this->platform->getIdentitySequenceName('"mytable"', '"mycolumn"'));
    }

    /** @dataProvider dataCreateSequenceWithCache */
    public function testCreateSequenceWithCache(int $cacheSize, string $expectedSql): void
    {
        $sequence = new Sequence('foo', 1, 1, $cacheSize);
        self::assertStringContainsString($expectedSql, $this->platform->getCreateSequenceSQL($sequence));
    }

    /** @return mixed[][] */
    public static function dataCreateSequenceWithCache(): iterable
    {
        return [
            [1, '"cache":1'],
            [0, '"cache":0'],
            [3, 'CACHE 3'],
        ];
    }


    /**
     * {@inheritDoc}
     */
    protected function getQuotedAlterTableRenameColumnSQL(): array
    {
        return [
            'ALTER TABLE mytable ALTER COLUMN unquoted1 TO unquoted',
            'ALTER TABLE mytable ALTER COLUMN unquoted2 TO "where"',
            'ALTER TABLE mytable ALTER COLUMN unquoted3 TO "foo"',
            'ALTER TABLE mytable ALTER COLUMN "create" TO reserved_keyword',
            'ALTER TABLE mytable ALTER COLUMN "table" TO "from"',
            'ALTER TABLE mytable ALTER COLUMN "select" TO "bar"',
            'ALTER TABLE mytable ALTER COLUMN quoted1 TO quoted',
            'ALTER TABLE mytable ALTER COLUMN quoted2 TO "and"',
            'ALTER TABLE mytable ALTER COLUMN quoted3 TO "baz"',
        ];
    }

    /**
     * {@inheritDoc}
     */
    protected function getQuotedAlterTableChangeColumnLengthSQL(): array
    {
        self::markTestIncomplete('Not implemented yet');
    }



    protected function getQuotesDropForeignKeySQL(): string
    {
        return 'ALTER TABLE "table" DROP CONSTRAINT "select"';
    }

    public function testReturnsGuidTypeDeclarationSQL(): void
    {
        self::assertSame('VARCHAR(36)', $this->platform->getGuidTypeDeclarationSQL([]));
    }

    /**
     * {@inheritDoc}
     */
    public function getAlterTableRenameColumnSQL(): array
    {
        return ['ALTER TABLE foo ALTER COLUMN bar TO baz'];
    }

    /**
     * @param string $expectedSql
     *
     * @dataProvider getReturnsDropAutoincrementSQL
     */
    public function testReturnsDropAutoincrementSQL(string $table, string $expectedSql): void
    {
        self::assertSame($expectedSql, $this->platform->getDropAutoincrementSql($table));
    }

    /** @return mixed[][] */
    public static function getReturnsDropAutoincrementSQL(): iterable
    {
        return [
            [
                'myTable',
                '',
            ],
            [
                '"myTable"',
               '',
            ],
            [
                'table',
                '',
            ],
        ];
    }

    /**
     * {@inheritDoc}
     */
    protected function getCommentOnColumnSQL(): array
    {
        return [
            'COMMENT ON COLUMN foo.bar IS \'comment\'',
            'COMMENT ON COLUMN "Foo"."BAR" IS \'comment\'',
            'COMMENT ON COLUMN "select"."from" IS \'comment\'',
        ];
    }

    public function testAltersTableColumnCommentWithExplicitlyQuotedIdentifiers(): void
    {
        $table1 = new Table('"foo"', [new Column('"bar"', Type::getType(Types::INTEGER))]);
        $table2 = new Table('"foo"', [new Column('"bar"', Type::getType(Types::INTEGER), ['comment' => 'baz'])]);

        $comparator = new Comparator();

        $tableDiff = $comparator->diffTable($table1, $table2);

        self::assertInstanceOf(TableDiff::class, $tableDiff);
        self::assertSame(
            ['COMMENT ON COLUMN "foo"."bar" IS \'baz\''],
            $this->platform->getAlterTableSQL($tableDiff),
        );
    }

    public function testQuotedTableNames(): void
    {
        $table = new Table('"test"');
        $table->addColumn('"id"', Types::INTEGER, ['autoincrement' => true]);

        // assert tabel
        self::assertTrue($table->isQuoted());
        self::assertEquals('test', $table->getName());
        self::assertEquals('"test"', $table->getQuotedName($this->platform));

        $sql = $this->platform->getCreateTableSQL($table);
        self::assertEquals('CREATE TABLE "test" ("id" INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL)', $sql[0]);
    }

    /** @dataProvider getReturnsGetListTableColumnsSQL */
    public function testReturnsGetListTableColumnsSQL(?string $database, string $expectedSql): void
    {
        // note: this assertion is a bit strict, as it compares a full SQL string.
        // Should this break in future, then please try to reduce the matching to substring matching while reworking
        // the tests
        self::assertEquals($expectedSql, $this->platform->getListTableColumnsSQL('"test"', $database));
    }

    /** @return mixed[][] */
    public static function getReturnsGetListTableColumnsSQL(): iterable
    {
        return [
            [
                null,
                <<<'SQL'
SELECT TRIM(r.RDB$FIELD_NAME) AS "FIELD_NAME",
TRIM(f.RDB$FIELD_NAME) AS "FIELD_DOMAIN",
TRIM(f.RDB$FIELD_TYPE) AS "FIELD_TYPE",
TRIM(typ.RDB$TYPE_NAME) AS "FIELD_TYPE_NAME",
f.RDB$FIELD_SUB_TYPE AS "FIELD_SUB_TYPE",
f.RDB$FIELD_LENGTH AS "FIELD_LENGTH",
f.RDB$CHARACTER_LENGTH AS "FIELD_CHAR_LENGTH",
f.RDB$FIELD_PRECISION AS "FIELD_PRECISION",
f.RDB$FIELD_SCALE AS "FIELD_SCALE",
MIN(TRIM(rc.RDB$CONSTRAINT_TYPE)) AS "FIELD_CONSTRAINT_TYPE",
MIN(TRIM(i.RDB$INDEX_NAME)) AS "FIELD_INDEX_NAME",
r.RDB$NULL_FLAG as "FIELD_NOT_NULL_FLAG",
r.RDB$DEFAULT_SOURCE AS "FIELD_DEFAULT_SOURCE",
r.RDB$FIELD_POSITION AS "FIELD_POSITION",
r.RDB$DESCRIPTION AS "FIELD_DESCRIPTION",
f.RDB$CHARACTER_SET_ID as "CHARACTER_SET_ID",
TRIM(cs.RDB$CHARACTER_SET_NAME) as "CHARACTER_SET_NAME",
f.RDB$COLLATION_ID as "COLLATION_ID",
TRIM(cl.RDB$COLLATION_NAME) as "COLLATION_NAME",
TRIM(r.RDB$IDENTITY_TYPE) AS "IDENTITY_TYPE" 
FROM RDB$RELATION_FIELDS r
LEFT OUTER JOIN RDB$FIELDS f ON r.RDB$FIELD_SOURCE = f.RDB$FIELD_NAME
LEFT OUTER JOIN RDB$INDEX_SEGMENTS s ON s.RDB$FIELD_NAME=r.RDB$FIELD_NAME
LEFT OUTER JOIN RDB$INDICES i ON i.RDB$INDEX_NAME = s.RDB$INDEX_NAME AND i.RDB$RELATION_NAME = r.RDB$RELATION_NAME
LEFT OUTER JOIN RDB$RELATION_CONSTRAINTS rc ON rc.RDB$INDEX_NAME = s.RDB$INDEX_NAME AND rc.RDB$INDEX_NAME = i.RDB$INDEX_NAME AND rc.RDB$RELATION_NAME = i.RDB$RELATION_NAME
LEFT OUTER JOIN RDB$REF_CONSTRAINTS REFC ON rc.RDB$CONSTRAINT_NAME = refc.RDB$CONSTRAINT_NAME
LEFT OUTER JOIN RDB$TYPES typ ON typ.RDB$FIELD_NAME = 'RDB$FIELD_TYPE' AND typ.RDB$TYPE = f.RDB$FIELD_TYPE
LEFT OUTER JOIN RDB$TYPES sub ON sub.RDB$FIELD_NAME = 'RDB$FIELD_SUB_TYPE' AND sub.RDB$TYPE = f.RDB$FIELD_SUB_TYPE
LEFT OUTER JOIN RDB$CHARACTER_SETS cs ON cs.RDB$CHARACTER_SET_ID = f.RDB$CHARACTER_SET_ID
LEFT OUTER JOIN RDB$COLLATIONS cl ON cl.RDB$CHARACTER_SET_ID = f.RDB$CHARACTER_SET_ID AND cl.RDB$COLLATION_ID = f.RDB$COLLATION_ID
WHERE UPPER(r.RDB$RELATION_NAME) = UPPER('test')
GROUP BY "FIELD_NAME", "FIELD_DOMAIN", "FIELD_TYPE", "FIELD_TYPE_NAME", "FIELD_SUB_TYPE",  "FIELD_LENGTH",
         "FIELD_CHAR_LENGTH", "FIELD_PRECISION", "FIELD_SCALE", "FIELD_NOT_NULL_FLAG", "FIELD_DEFAULT_SOURCE",
         "FIELD_POSITION",
         "CHARACTER_SET_ID",
         "CHARACTER_SET_NAME",
         "COLLATION_ID",
         "COLLATION_NAME",
         "FIELD_DESCRIPTION",
         "IDENTITY_TYPE"
ORDER BY "FIELD_POSITION"
SQL
,
            ],
            [
                '/',
                <<<'SQL'
SELECT TRIM(r.RDB$FIELD_NAME) AS "FIELD_NAME",
TRIM(f.RDB$FIELD_NAME) AS "FIELD_DOMAIN",
TRIM(f.RDB$FIELD_TYPE) AS "FIELD_TYPE",
TRIM(typ.RDB$TYPE_NAME) AS "FIELD_TYPE_NAME",
f.RDB$FIELD_SUB_TYPE AS "FIELD_SUB_TYPE",
f.RDB$FIELD_LENGTH AS "FIELD_LENGTH",
f.RDB$CHARACTER_LENGTH AS "FIELD_CHAR_LENGTH",
f.RDB$FIELD_PRECISION AS "FIELD_PRECISION",
f.RDB$FIELD_SCALE AS "FIELD_SCALE",
MIN(TRIM(rc.RDB$CONSTRAINT_TYPE)) AS "FIELD_CONSTRAINT_TYPE",
MIN(TRIM(i.RDB$INDEX_NAME)) AS "FIELD_INDEX_NAME",
r.RDB$NULL_FLAG as "FIELD_NOT_NULL_FLAG",
r.RDB$DEFAULT_SOURCE AS "FIELD_DEFAULT_SOURCE",
r.RDB$FIELD_POSITION AS "FIELD_POSITION",
r.RDB$DESCRIPTION AS "FIELD_DESCRIPTION",
f.RDB$CHARACTER_SET_ID as "CHARACTER_SET_ID",
TRIM(cs.RDB$CHARACTER_SET_NAME) as "CHARACTER_SET_NAME",
f.RDB$COLLATION_ID as "COLLATION_ID",
TRIM(cl.RDB$COLLATION_NAME) as "COLLATION_NAME",
TRIM(r.RDB$IDENTITY_TYPE) AS "IDENTITY_TYPE" 
FROM RDB$RELATION_FIELDS r
LEFT OUTER JOIN RDB$FIELDS f ON r.RDB$FIELD_SOURCE = f.RDB$FIELD_NAME
LEFT OUTER JOIN RDB$INDEX_SEGMENTS s ON s.RDB$FIELD_NAME=r.RDB$FIELD_NAME
LEFT OUTER JOIN RDB$INDICES i ON i.RDB$INDEX_NAME = s.RDB$INDEX_NAME AND i.RDB$RELATION_NAME = r.RDB$RELATION_NAME
LEFT OUTER JOIN RDB$RELATION_CONSTRAINTS rc ON rc.RDB$INDEX_NAME = s.RDB$INDEX_NAME AND rc.RDB$INDEX_NAME = i.RDB$INDEX_NAME AND rc.RDB$RELATION_NAME = i.RDB$RELATION_NAME
LEFT OUTER JOIN RDB$REF_CONSTRAINTS REFC ON rc.RDB$CONSTRAINT_NAME = refc.RDB$CONSTRAINT_NAME
LEFT OUTER JOIN RDB$TYPES typ ON typ.RDB$FIELD_NAME = 'RDB$FIELD_TYPE' AND typ.RDB$TYPE = f.RDB$FIELD_TYPE
LEFT OUTER JOIN RDB$TYPES sub ON sub.RDB$FIELD_NAME = 'RDB$FIELD_SUB_TYPE' AND sub.RDB$TYPE = f.RDB$FIELD_SUB_TYPE
LEFT OUTER JOIN RDB$CHARACTER_SETS cs ON cs.RDB$CHARACTER_SET_ID = f.RDB$CHARACTER_SET_ID
LEFT OUTER JOIN RDB$COLLATIONS cl ON cl.RDB$CHARACTER_SET_ID = f.RDB$CHARACTER_SET_ID AND cl.RDB$COLLATION_ID = f.RDB$COLLATION_ID
WHERE UPPER(r.RDB$RELATION_NAME) = UPPER('test')
GROUP BY "FIELD_NAME", "FIELD_DOMAIN", "FIELD_TYPE", "FIELD_TYPE_NAME", "FIELD_SUB_TYPE",  "FIELD_LENGTH",
         "FIELD_CHAR_LENGTH", "FIELD_PRECISION", "FIELD_SCALE", "FIELD_NOT_NULL_FLAG", "FIELD_DEFAULT_SOURCE",
         "FIELD_POSITION",
         "CHARACTER_SET_ID",
         "CHARACTER_SET_NAME",
         "COLLATION_ID",
         "COLLATION_NAME",
         "FIELD_DESCRIPTION",
         "IDENTITY_TYPE"
ORDER BY "FIELD_POSITION"
SQL
,
            ],
        ];
    }

    protected function getQuotesReservedKeywordInUniqueConstraintDeclarationSQL(): string
    {
        return 'CONSTRAINT "select" UNIQUE (foo)';
    }

    protected function getQuotesReservedKeywordInIndexDeclarationSQL(): string
    {
        return 'INDEX "select" (foo)';
    }

    protected function getQuotesReservedKeywordInTruncateTableSQL(): string
    {
        return 'DELETE FROM "select"';
    }


    /**
     * {@inheritDoc}
     */
    protected function getGeneratesAlterTableRenameIndexUsedByForeignKeySQL(): array
    {
        return [
            'DROP INDEX idx_foo',
            'CREATE INDEX idx_foo_renamed ON mytable (foo)'
        ];
    }


    public function testQuotesTableNameInListTableIndexesSQL(): void
    {
        self::assertStringContainsStringIgnoringCase(
            "'Foo''Bar\\'",
            $this->platform->getListTableIndexesSQL("Foo'Bar\\"),
        );
    }

    public function testQuotesTableNameInListTableForeignKeysSQL(): void
    {
        self::assertStringContainsStringIgnoringCase(
            "'Foo''Bar\\'",
            $this->platform->getListTableForeignKeysSQL("Foo'Bar\\"),
        );
    }

    public function testQuotesTableNameInListTableConstraintsSQL(): void
    {
        self::assertStringContainsStringIgnoringCase(
            "'Foo''Bar\\'",
            $this->platform->getListTableConstraintsSQL("Foo'Bar\\"),
        );
    }

    public function testQuotesTableNameInListTableColumnsSQL(): void
    {
        self::assertStringContainsStringIgnoringCase(
            "'Foo''Bar\\'",
            $this->platform->getListTableColumnsSQL("Foo'Bar\\"),
        );
    }

    public function testQuotesDatabaseNameInListTableColumnsSQL(): void
    {
        self::assertStringContainsStringIgnoringCase(
            "'Foo''Bar\\'",
            $this->platform->getListTableColumnsSQL("Foo'Bar\\"),
        );
    }

    /** @return array<int, array{string, array<string, mixed>}> */
    public static function asciiStringSqlDeclarationDataProvider(): array
    {
        return [
            ['VARCHAR(12)', ['length' => 12]],
            ['CHAR(12)', ['length' => 12, 'fixed' => true]],
        ];
    }

    protected function getLimitOffsetCastToIntExpectedQuery(): string
    {
        return 'SELECT * FROM user ROWS 3 TO 3';
    }

    public function testInitializesDoctrineTypeMappings(): void
    {
        self::assertTrue($this->platform->hasDoctrineTypeMappingFor('boolean'));
        self::assertSame(Types::BOOLEAN, $this->platform->getDoctrineTypeMapping('boolean'));
    }
}
